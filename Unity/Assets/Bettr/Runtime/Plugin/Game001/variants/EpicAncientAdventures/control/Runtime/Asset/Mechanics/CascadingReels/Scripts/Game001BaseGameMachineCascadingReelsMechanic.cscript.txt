require "math"
require "Core"

Game001BaseGameMachineCascadingReelsMechanic = {
}

function Game001BaseGameMachineCascadingReelsMechanic:new(o)
	o = o or {}
	setmetatable(o, self)
	self.__index = self
	return o
end

function Game001BaseGameMachineCascadingReelsMechanic:OnError(callStack)
	System.Error("BaseGameMachineCascadingReelsMechanic Error CallStack: {0}", callStack)
end

function Game001BaseGameMachineCascadingReelsMechanic:Initialize(machine)
end

function Game001BaseGameMachineCascadingReelsMechanic:HasCascade(machine)
    if Game001BaseGameCascadingReelsSummary == nil then
        return false
    end
    if Game001BaseGameCascadingReelsSummary.CascadingReels == nil then
        return false
    end
    local cascadeCount = Game001BaseGameCascadingReelsSummary.CascadingReels.First.CascadeCount
    return cascadeCount > 0
end

function Game001BaseGameMachineCascadingReelsMechanic:StartCascade(machine)
    local counterIndex = 1
    local cascadeCount = Game001BaseGameCascadingReelsSummary.CascadingReels.First.CascadeCount
    local cascades = Game001BaseGameCascadingReels.CascadingReels.Array
    local cascadesMatrix = Game001BaseGameCascadingReelsMatrix

    while counterIndex <= cascadeCount do
        local cascade = cascades[counterIndex]
        local cascadeID = cascade.Cascade
        local cascadeAction = cascade.Action

        local cascadeMatrix = nil
        local cascadeMatrixCount = 0
        if cascadeAction ~= "SymbolWays" then
            cascadeMatrix = cascadesMatrix[cascadeID] and cascadesMatrix[cascadeID].Array or {}
            cascadeMatrixCount = cascadesMatrix[cascadeID] and cascadesMatrix[cascadeID].Count or 0
        end

        if cascadeAction == "SymbolRemoval" then
            System.Print("cascadeID={0}, SymbolRemovalActions", cascadeID)
            self:SymbolRemovalActions(cascadeMatrix, cascadeMatrixCount, cascadeAction)
            counterIndex = counterIndex + 1

            while counterIndex <= cascadeCount and cascades[counterIndex].Action == "SymbolCascade" do
                local cascade = cascades[counterIndex]
                local cascadeID = cascade.Cascade
                local cascadeAction = cascade.Action

                cascadeMatrix = cascadesMatrix[cascadeID] and cascadesMatrix[cascadeID].Array or {}
                cascadeMatrixCount = cascadesMatrix[cascadeID] and cascadesMatrix[cascadeID].Count or 0

                System.Print("cascadeID={0}, SymbolCascadeActions", cascadeID)
                self:SymbolCascadeActions(cascadeMatrix, cascadeMatrixCount, cascadeAction)
                counterIndex = counterIndex + 1
            end
        elseif cascadeAction == "SymbolWays" then
            System.Print("cascadeID={0}, SymbolWaysActions", cascadeID)
            self:SymbolWaysActions(machine, cascadeID)
            counterIndex = counterIndex + 1

            if counterIndex <= cascadeCount and cascades[counterIndex].Action == "SymbolRemoval" then
                local cascade = cascades[counterIndex]
                local cascadeID = cascade.Cascade
                local cascadeAction = cascade.Action

                cascadeMatrix = cascadesMatrix[cascadeID] and cascadesMatrix[cascadeID].Array or {}
                cascadeMatrixCount = cascadesMatrix[cascadeID] and cascadesMatrix[cascadeID].Count or 0

                System.Print("cascadeID={0}, SymbolRemovalActions", cascadeID)
                self:SymbolRemovalActions(cascadeMatrix, cascadeMatrixCount, cascadeAction)
                counterIndex = counterIndex + 1

                while counterIndex <= cascadeCount and cascades[counterIndex].Action == "SymbolCascade" do
                    local cascade = cascades[counterIndex]
                    local cascadeID = cascade.Cascade
                    local cascadeAction = cascade.Action

                    cascadeMatrix = cascadesMatrix[cascadeID] and cascadesMatrix[cascadeID].Array or {}
                    cascadeMatrixCount = cascadesMatrix[cascadeID] and cascadesMatrix[cascadeID].Count or 0

                    System.Print("cascadeID={0}, SymbolCascadeActions", cascadeID)
                    self:SymbolCascadeActions(cascadeMatrix, cascadeMatrixCount, cascadeAction)
                    counterIndex = counterIndex + 1
                end
            end
        else
            System.Print("Unhandled cascade action type: {0}", cascadeAction)
            counterIndex = counterIndex + 1
        end
    end
end

function Game001BaseGameMachineCascadingReelsMechanic:SymbolWaysActions(machine, cascadeID)
    series
        do  
            local filteredWaysSummary = {}
            for _, summary in ipairs(Game001BaseGameCascadingReelsWaysSummary.Ways.Array) do
                if summary.Cascade == cascadeID then
                    filteredWaysSummary = {
                        WaysCount = summary.WaysCount,
                        DisplayLoopDuration = summary.DisplayLoopDuration,
                        DisplayLoopStartDelay = summary.DisplayLoopStartDelay,
                        DisplayLoopEndDelay = summary.DisplayLoopEndDelay,
                        Pays = summary.Pays
                    }
                    break
                end
            end

            local filteredWays = {}
            for _, way in ipairs(Game001BaseGameCascadingReelsWays.Ways.Array) do
                if way.Cascade == cascadeID then
                    table.insert(filteredWays, {
                        Symbol = way.Symbol,
                        ReelCount = way.ReelCount,
                        SymbolCount = way.SymbolCount,
                        Multiplier = way.Multiplier,
                        Pay = way.Pay,
                        Pays = way.Pays
                    })
                end
            end

            local filteredWaysMatrix = {}
            for symbol, symbolData in pairs(Game001BaseGameCascadingReelsWaysMatrix) do
                local matchingRows = {} -- Temporary table to store matching rows for the current symbol
            
                -- Loop through the Array of rows for the current symbol
                for _, matrixRow in ipairs(symbolData.Array) do
                    if matrixRow.Cascade == cascadeID then
                        table.insert(matchingRows, matrixRow)
                    end
                end
            
                -- Only include the symbol if there are matching rows
                if #matchingRows > 0 then
                    filteredWaysMatrix[symbol] = {
                        Array = matchingRows
                    }
                end
                                
            end

            local filteredWaysState = {}
            if Game001BaseGameCascadingReelsWaysState and Game001BaseGameCascadingReelsWaysState.Ways then
                local waysArray = Game001BaseGameCascadingReelsWaysState.Ways.Array
                if waysArray then
                    for _, state in ipairs(waysArray) do
                        if state.Cascade == cascadeID then
                            filteredWaysState = state
                            break
                        end
                    end
                end
            end

            Game001BaseGameWaysSummary = {
                Ways = {
                    First = filteredWaysSummary
                }
            }
            Game001BaseGameWays = {
                Ways = {
                    Array = filteredWays
                }
            }
            Game001BaseGameWaysMatrix = filteredWaysMatrix
            Game001BaseGameWaysState = {
                Ways = {
                    First = filteredWaysState
                }
            }
                                    
        end
        do
            BettrUser.InitSpinCoins()
            machine.Mechanics.WaysMechanic:TryPaying(machine)
        end
        do
            machine.Mechanics.WaysMechanic:BaseGamePayout(machine)
        end
        do
            BettrAudioController.StopAudio()
            BettrUserController.DisableUserInSlamStopMode()
            machine:RollupCredits()
        end
    end
end

function Game001BaseGameMachineCascadingReelsMechanic:SymbolRemovalActions(cascadeMatrix, cascadeMatrixCount, cascadeAction)
    for matrixIndex = 1, cascadeMatrixCount parallel do
        local cascadeMatrixRow = cascadeMatrix[matrixIndex]
        local cascadeReelID = cascadeMatrixRow.ReelID
        local cascadeRowIndex = cascadeMatrixRow.RowIndex 
        self:SymbolRemovalAction(cascadeReelID, cascadeRowIndex)
    end
end

function Game001BaseGameMachineCascadingReelsMechanic:SymbolRemovalAction(reelID, rowIndex)
    local reel = _G["Game001BaseGame" .. reelID]
    local luaRowIndex = rowIndex + 1
    local symbolGroupProperty = reel["SymbolGroup" .. luaRowIndex]
    reel.BettrReelController.SymbolRemovalAction(symbolGroupProperty)
end

function Game001BaseGameMachineCascadingReelsMechanic:SymbolCascadeActions(cascadeMatrix, cascadeMatrixCount, cascadeAction)
    for matrixIndex = 1, cascadeMatrixCount parallel do
        local cascadeMatrixRow = cascadeMatrix[matrixIndex]
        local cascadeReelID = cascadeMatrixRow.ReelID
        local rowIndex = cascadeMatrixRow.RowIndex
        local cascadeDistance = cascadeMatrixRow.CascadeDistance 
        local cascadeSymbol = cascadeMatrixRow.Symbol
        self:SymbolCascadeAction(cascadeReelID, rowIndex, cascadeDistance, cascadeSymbol)
    end
end

function Game001BaseGameMachineCascadingReelsMechanic:SymbolCascadeAction(reelID, rowIndex, cascadeDistance, cascadeSymbol)
    series
        do
            local luaRowIndex = rowIndex + 1
            local reel = _G["Game001BaseGame" .. reelID]
            local symbolGroupProperty = reel["SymbolGroup" .. luaRowIndex]
            symbolGroupProperty.Current.SetActive(true)
            reel.BettrReelController.SymbolCascadeAction(luaRowIndex, cascadeDistance, cascadeSymbol)
        end
    end
end