require "math"
require "Core"

Game001BaseGameMachineCascadingReelsMechanic = {
}

function Game001BaseGameMachineCascadingReelsMechanic:new(o)
	o = o or {}
	setmetatable(o, self)
	self.__index = self
	return o
end

function Game001BaseGameMachineCascadingReelsMechanic:OnError(callStack)
	System.Error("BaseGameMachineCascadingReelsMechanic Error CallStack: {0}", callStack)
end

function Game001BaseGameMachineCascadingReelsMechanic:Initialize(machine)
end

function Game001BaseGameMachineCascadingReelsMechanic:OnBaseGameSpinCompleted(machine)
    series
        do
            self:StartCascade(machine)
        end        
        do
            Game001BaseGameState.SpinState.First.State = "Completed"
            Game001BaseGameState.DisplayState.First.State = "Idle" 
        end
    end
end

function Game001BaseGameMachineCascadingReelsMechanic:StartCascade(machine)
    local counterIndex = 1
    local cascadeCount = Game001BaseGameCascadingReelsSummary.CascadingReels.First.CascadeCount
    local cascades = Game001BaseGameCascadingReels.CascadingReels.Array
    local cascadesMatrix = Game001BaseGameCascadingReelsMatrix

    while counterIndex <= cascadeCount do
        local cascade = cascades[counterIndex]
        local cascadeID = cascade.Cascade
        local cascadeAction = cascade.Action

--        System.Print("Processing cascadeID={0} counterIndex={1} cascadeAction={2}", cascadeID, counterIndex, cascadeAction)

        local cascadeMatrix = nil
        local cascadeMatrixCount = 0
        if cascadeAction ~= "SymbolWays" then
            cascadeMatrix = cascadesMatrix[cascadeID] and cascadesMatrix[cascadeID].Array or {}
            cascadeMatrixCount = cascadesMatrix[cascadeID] and cascadesMatrix[cascadeID].Count or 0
        end

        if cascadeAction == "SymbolRemoval" then
            self:SymbolRemovalActions(cascadeMatrix, cascadeMatrixCount, cascadeAction)
            counterIndex = counterIndex + 1

            while counterIndex <= cascadeCount and cascades[counterIndex].Action == "SymbolCascade" do
                local cascade = cascades[counterIndex]
                local cascadeID = cascade.Cascade
                local cascadeAction = cascade.Action

                System.Print("Processing cascadeID={0} counterIndex={1} cascadeAction={2}", cascadeID, counterIndex, cascadeAction)

                cascadeMatrix = cascadesMatrix[cascadeID] and cascadesMatrix[cascadeID].Array or {}
                cascadeMatrixCount = cascadesMatrix[cascadeID] and cascadesMatrix[cascadeID].Count or 0

                self:SymbolCascadeActions(cascadeMatrix, cascadeMatrixCount, cascadeAction)
                counterIndex = counterIndex + 1
            end
        elseif cascadeAction == "SymbolWays" then
            self:SymbolWaysActions(machine, cascadeID)
            counterIndex = counterIndex + 1

            if counterIndex <= cascadeCount and cascades[counterIndex].Action == "SymbolRemoval" then
                local cascade = cascades[counterIndex]
                local cascadeID = cascade.Cascade
                local cascadeAction = cascade.Action

                System.Print("Processing cascadeID={0} counterIndex={1} cascadeAction={2}", cascadeID, counterIndex, cascadeAction)

                cascadeMatrix = cascadesMatrix[cascadeID] and cascadesMatrix[cascadeID].Array or {}
                cascadeMatrixCount = cascadesMatrix[cascadeID] and cascadesMatrix[cascadeID].Count or 0

                self:SymbolRemovalActions(cascadeMatrix, cascadeMatrixCount, cascadeAction)
                counterIndex = counterIndex + 1

                while counterIndex <= cascadeCount and cascades[counterIndex].Action == "SymbolCascade" do
                    local cascade = cascades[counterIndex]
                    local cascadeID = cascade.Cascade
                    local cascadeAction = cascade.Action

                    System.Print("Processing cascadeID={0} counterIndex={1} cascadeAction={2}", cascadeID, counterIndex, cascadeAction)

                    cascadeMatrix = cascadesMatrix[cascadeID] and cascadesMatrix[cascadeID].Array or {}
                    cascadeMatrixCount = cascadesMatrix[cascadeID] and cascadesMatrix[cascadeID].Count or 0

                    self:SymbolCascadeActions(cascadeMatrix, cascadeMatrixCount, cascadeAction)
                    counterIndex = counterIndex + 1
                end
            end
        else
            System.Print("Unhandled cascade action type: {0}", cascadeAction)
            counterIndex = counterIndex + 1
        end
    end
end

function Game001BaseGameMachineCascadingReelsMechanic:SymbolWaysActions(machine, cascadeID)
    series
        do  
            local filteredWaysSummary = {}
            for _, summary in ipairs(Game001BaseGameCascadingReelsWaysSummary.Ways.Array) do
                if summary.Cascade == cascadeID then
                    filteredWaysSummary = {
                        WaysCount = summary.WaysCount,
                        DisplayLoopDuration = summary.DisplayLoopDuration,
                        DisplayLoopStartDelay = summary.DisplayLoopStartDelay,
                        DisplayLoopEndDelay = summary.DisplayLoopEndDelay,
                        Pays = summary.Pays
                    }
                    break
                end
            end

            local filteredWays = {}
            for _, way in ipairs(Game001BaseGameCascadingReelsWays.Ways.Array) do
                if way.Cascade == cascadeID then
                    table.insert(filteredWays, {
                        Symbol = way.Symbol,
                        ReelCount = way.ReelCount,
                        SymbolCount = way.SymbolCount,
                        Multiplier = way.Multiplier,
                        Pay = way.Pay,
                        Pays = way.Pays
                    })
                end
            end

            local filteredWaysMatrix = {}
            for _, matrixRow in ipairs(Game001BaseGameCascadingReelsWaysMatrix) do
                if matrixRow.Cascade == cascadeID then
                    if not filteredWaysMatrix[matrixRow.Symbol] then
                        filteredWaysMatrix[matrixRow.Symbol] = {
                            Array = {},
                            First = nil,
                            Last = nil,
                            Count = 0
                        }
                    end
                    local matrixEntry = {
                        ReelID = matrixRow.ReelID,
                        RowIndex = matrixRow.RowIndex,
                        IsWild = matrixRow.IsWild,
                        IsMultiplier = matrixRow.IsMultiplier,
                        Multiplier = matrixRow.Multiplier
                    }
                    table.insert(filteredWaysMatrix[matrixRow.Symbol].Array, matrixEntry)
                    filteredWaysMatrix[matrixRow.Symbol].Count = #filteredWaysMatrix[matrixRow.Symbol].Array
                    filteredWaysMatrix[matrixRow.Symbol].First = filteredWaysMatrix[matrixRow.Symbol].Array[1]
                    filteredWaysMatrix[matrixRow.Symbol].Last = filteredWaysMatrix[matrixRow.Symbol].Array[#filteredWaysMatrix[matrixRow.Symbol].Array]
                end
            end

            local filteredWaysState = {}
            if Game001BaseGameCascadingReelsWaysState and Game001BaseGameCascadingReelsWaysState.Ways then
                local waysArray = Game001BaseGameCascadingReelsWaysState.Ways.Array
                if waysArray then
                    for _, state in ipairs(waysArray) do
                        if state.Cascade == cascadeID then
                            filteredWaysState = state
                            break
                        end
                    end
                end
            end

            Game001BaseGameWaysSummary = {
                Ways = {
                    First = filteredWaysSummary
                }
            }
            Game001BaseGameWays = {
                Ways = {
                    Array = filteredWays
                }
            }
            Game001BaseGameWaysMatrix = filteredWaysMatrix
            Game001BaseGameWaysState = {
                Ways = {
                    First = filteredWaysState
                }
            }
        end
    end
end

function Game001BaseGameMachineCascadingReelsMechanic:SymbolRemovalActions(cascadeMatrix, cascadeMatrixCount, cascadeAction)
    for matrixIndex = 1, cascadeMatrixCount parallel do
        local cascadeMatrixRow = cascadeMatrix[matrixIndex]
        local cascadeReelID = cascadeMatrixRow.ReelID
        local cascadeRowIndex = cascadeMatrixRow.RowIndex 
        System.Print("cascadeReelID={0} cascadeRowIndex={1} cascadeAction={2}", cascadeReelID, cascadeRowIndex, cascadeAction)                    
        self:SymbolRemovalAction(cascadeReelID, cascadeRowIndex)
    end
end

function Game001BaseGameMachineCascadingReelsMechanic:SymbolRemovalAction(reelID, rowIndex)
    local reel = _G["Game001BaseGame" .. reelID]
    local luaRowIndex = rowIndex + 1
    local symbolGroupProperty = reel["SymbolGroup" .. luaRowIndex]
    reel.BettrReelController.SymbolRemovalAction(symbolGroupProperty)
end

function Game001BaseGameMachineCascadingReelsMechanic:SymbolCascadeActions(cascadeMatrix, cascadeMatrixCount, cascadeAction)
    for matrixIndex = 1, cascadeMatrixCount parallel do
        local cascadeMatrixRow = cascadeMatrix[matrixIndex]
        local cascadeReelID = cascadeMatrixRow.ReelID
        local rowIndex = cascadeMatrixRow.RowIndex
        local cascadeDistance = cascadeMatrixRow.CascadeDistance 
        local cascadeSymbol = cascadeMatrixRow.Symbol
        self:SymbolCascadeAction(cascadeReelID, rowIndex, cascadeDistance, cascadeSymbol)
    end
end

function Game001BaseGameMachineCascadingReelsMechanic:SymbolCascadeAction(reelID, rowIndex, cascadeDistance, cascadeSymbol)
    series
        do
            local luaRowIndex = rowIndex + 1
            local reel = _G["Game001BaseGame" .. reelID]
            local symbolGroupProperty = reel["SymbolGroup" .. luaRowIndex]
            symbolGroupProperty.Current.SetActive(true)
            reel.BettrReelController.SymbolCascadeAction(luaRowIndex, cascadeDistance, cascadeSymbol)
        end
    end
end



