require "math"
require "Core"

Game001BaseGameMachineCascadingReelsMechanic = {
}

function Game001BaseGameMachineCascadingReelsMechanic:new(o)
	o = o or {}
	setmetatable(o, self)
	self.__index = self
	return o
end

function Game001BaseGameMachineCascadingReelsMechanic:OnError(callStack)
	System.Error("BaseGameMachineCascadingReelsMechanic Error CallStack: {0}", callStack)
end

function Game001BaseGameMachineCascadingReelsMechanic:Initialize(machine)
end

function Game001BaseGameMachineCascadingReelsMechanic:OnBaseGameSpinCompleted(machine)
    series
        do
            if self:HasCascade(machine) then
                self:StartCascade(machine)
            end
        end        
        do
            Game001BaseGameState.SpinState.First.State = "Completed"
            Game001BaseGameState.DisplayState.First.State = "Idle" 
        end
    end
end

function Game001BaseGameMachineCascadingReelsMechanic:HasCascade(machine)
    if Game001BaseGameCascadingReelsSummary == nil then
        return false
    end
    if Game001BaseGameCascadingReelsSummary.CascadingReels == nil then
        return false
    end
    local cascadeCount = Game001BaseGameCascadingReelsSummary.CascadingReels.First.CascadeCount
    return cascadeCount > 0
end

function Game001BaseGameMachineCascadingReelsMechanic:StartCascade(machine)
    local counterIndex = 1
    local cascadeCount = Game001BaseGameCascadingReelsSummary.CascadingReels.First.CascadeCount
    local cascades = Game001BaseGameCascadingReels.CascadingReels.Array
    local cascadesMatrix = Game001BaseGameCascadingReelsMatrix

    while counterIndex <= cascadeCount do
        local cascade = cascades[counterIndex]
        local cascadeID = cascade.Cascade
        local cascadeAction = cascade.Action

        local cascadeMatrix = nil
        local cascadeMatrixCount = 0
        if cascadeAction ~= "SymbolWays" then
            cascadeMatrix = cascadesMatrix[cascadeID] and cascadesMatrix[cascadeID].Array or {}
            cascadeMatrixCount = cascadesMatrix[cascadeID] and cascadesMatrix[cascadeID].Count or 0
        end

        if cascadeAction == "SymbolRemoval" then
            self:SymbolRemovalActions(cascadeMatrix, cascadeMatrixCount, cascadeAction)
            counterIndex = counterIndex + 1

            while counterIndex <= cascadeCount and cascades[counterIndex].Action == "SymbolCascade" do
                local cascade = cascades[counterIndex]
                local cascadeID = cascade.Cascade
                local cascadeAction = cascade.Action

                cascadeMatrix = cascadesMatrix[cascadeID] and cascadesMatrix[cascadeID].Array or {}
                cascadeMatrixCount = cascadesMatrix[cascadeID] and cascadesMatrix[cascadeID].Count or 0

                self:SymbolCascadeActions(cascadeMatrix, cascadeMatrixCount, cascadeAction)
                counterIndex = counterIndex + 1
            end
        elseif cascadeAction == "SymbolWays" then
            self:SymbolWaysActions(machine, cascadeID)
            counterIndex = counterIndex + 1

            if counterIndex <= cascadeCount and cascades[counterIndex].Action == "SymbolRemoval" then
                local cascade = cascades[counterIndex]
                local cascadeID = cascade.Cascade
                local cascadeAction = cascade.Action

                cascadeMatrix = cascadesMatrix[cascadeID] and cascadesMatrix[cascadeID].Array or {}
                cascadeMatrixCount = cascadesMatrix[cascadeID] and cascadesMatrix[cascadeID].Count or 0

                self:SymbolRemovalActions(cascadeMatrix, cascadeMatrixCount, cascadeAction)
                counterIndex = counterIndex + 1

                while counterIndex <= cascadeCount and cascades[counterIndex].Action == "SymbolCascade" do
                    local cascade = cascades[counterIndex]
                    local cascadeID = cascade.Cascade
                    local cascadeAction = cascade.Action

                    cascadeMatrix = cascadesMatrix[cascadeID] and cascadesMatrix[cascadeID].Array or {}
                    cascadeMatrixCount = cascadesMatrix[cascadeID] and cascadesMatrix[cascadeID].Count or 0

                    self:SymbolCascadeActions(cascadeMatrix, cascadeMatrixCount, cascadeAction)
                    counterIndex = counterIndex + 1
                end
            end
        else
            System.Print("Unhandled cascade action type: {0}", cascadeAction)
            counterIndex = counterIndex + 1
        end
    end
end

function Game001BaseGameMachineCascadingReelsMechanic:SymbolWaysActions(machine, cascadeID)
    series
        do  
            local filteredWaysSummary = {}
            for _, summary in ipairs(Game001BaseGameCascadingReelsWaysSummary.Ways.Array) do
                if summary.Cascade == cascadeID then
                    filteredWaysSummary = {
                        WaysCount = summary.WaysCount,
                        DisplayLoopDuration = summary.DisplayLoopDuration,
                        DisplayLoopStartDelay = summary.DisplayLoopStartDelay,
                        DisplayLoopEndDelay = summary.DisplayLoopEndDelay,
                        Pays = summary.Pays
                    }
                    break
                end
            end

            local filteredWays = {}
            for _, way in ipairs(Game001BaseGameCascadingReelsWays.Ways.Array) do
                if way.Cascade == cascadeID then
                    table.insert(filteredWays, {
                        Symbol = way.Symbol,
                        ReelCount = way.ReelCount,
                        SymbolCount = way.SymbolCount,
                        Multiplier = way.Multiplier,
                        Pay = way.Pay,
                        Pays = way.Pays
                    })
                end
            end

            local filteredWaysMatrix = {}
            for symbol, symbolData in pairs(Game001BaseGameCascadingReelsWaysMatrix) do
                local matchingRows = {} -- Temporary table to store matching rows for the current symbol
            
                -- Loop through the Array of rows for the current symbol
                for _, matrixRow in ipairs(symbolData.Array) do
                    if matrixRow.Cascade == cascadeID then
                        table.insert(matchingRows, matrixRow)
                    end
                end
            
                -- Only include the symbol if there are matching rows
                if #matchingRows > 0 then
                    filteredWaysMatrix[symbol] = {
                        Array = matchingRows
                    }
                end
                                
            end

            local filteredWaysState = {}
            if Game001BaseGameCascadingReelsWaysState and Game001BaseGameCascadingReelsWaysState.Ways then
                local waysArray = Game001BaseGameCascadingReelsWaysState.Ways.Array
                if waysArray then
                    for _, state in ipairs(waysArray) do
                        if state.Cascade == cascadeID then
                            filteredWaysState = state
                            break
                        end
                    end
                end
            end

            Game001BaseGameWaysSummary = {
                Ways = {
                    First = filteredWaysSummary
                }
            }
            Game001BaseGameWays = {
                Ways = {
                    Array = filteredWays
                }
            }
            Game001BaseGameWaysMatrix = filteredWaysMatrix
            Game001BaseGameWaysState = {
                Ways = {
                    First = filteredWaysState
                }
            }
                                    
        end
        do
            BettrUser.InitSpinCoins()
            self:TryPaying(machine)
        end
        do
            self:DisplayWays(machine, cascadeID)
        end
        do
            BettrAudioController.StopAudio()
            BettrUserController.DisableUserInSlamStopMode()
            self:RollupCredits(machine)
        end
    end
end

function Game001BaseGameMachineCascadingReelsMechanic:SymbolRemovalActions(cascadeMatrix, cascadeMatrixCount, cascadeAction)
    for matrixIndex = 1, cascadeMatrixCount parallel do
        local cascadeMatrixRow = cascadeMatrix[matrixIndex]
        local cascadeReelID = cascadeMatrixRow.ReelID
        local cascadeRowIndex = cascadeMatrixRow.RowIndex 
        self:SymbolRemovalAction(cascadeReelID, cascadeRowIndex)
    end
end

function Game001BaseGameMachineCascadingReelsMechanic:SymbolRemovalAction(reelID, rowIndex)
    local reel = _G["Game001BaseGame" .. reelID]
    local luaRowIndex = rowIndex + 1
    local symbolGroupProperty = reel["SymbolGroup" .. luaRowIndex]
    reel.BettrReelController.SymbolRemovalAction(symbolGroupProperty)
end

function Game001BaseGameMachineCascadingReelsMechanic:SymbolCascadeActions(cascadeMatrix, cascadeMatrixCount, cascadeAction)
    for matrixIndex = 1, cascadeMatrixCount parallel do
        local cascadeMatrixRow = cascadeMatrix[matrixIndex]
        local cascadeReelID = cascadeMatrixRow.ReelID
        local rowIndex = cascadeMatrixRow.RowIndex
        local cascadeDistance = cascadeMatrixRow.CascadeDistance 
        local cascadeSymbol = cascadeMatrixRow.Symbol
        self:SymbolCascadeAction(cascadeReelID, rowIndex, cascadeDistance, cascadeSymbol)
    end
end

function Game001BaseGameMachineCascadingReelsMechanic:SymbolCascadeAction(reelID, rowIndex, cascadeDistance, cascadeSymbol)
    series
        do
            local luaRowIndex = rowIndex + 1
            local reel = _G["Game001BaseGame" .. reelID]
            local symbolGroupProperty = reel["SymbolGroup" .. luaRowIndex]
            symbolGroupProperty.Current.SetActive(true)
            reel.BettrReelController.SymbolCascadeAction(luaRowIndex, cascadeDistance, cascadeSymbol)
        end
    end
end

function Game001BaseGameMachineCascadingReelsMechanic:DisplayWays(machine, cascadeID)
    series
        do
            local waysSummary = Game001BaseGameWaysSummary.Ways.First
            local waysCount = waysSummary.WaysCount
            if waysCount == 0 then
                machine:OnPayingCompleted()
                return
            end
            local waysState = Game001BaseGameWaysState.Ways.First
            waysState.PaysRollup = 0
            local ways = Game001BaseGameWays.Ways.Array
            local waysMatrix = Game001BaseGameWaysMatrix
            local waysCount = waysSummary.WaysCount 
            local startDelay = waysSummary.DisplayLoopStartDelay
            local duration = waysSummary.DisplayLoopDuration
            local endDelay = waysSummary.DisplayLoopEndDelay            
            local waysIndex = waysState.WaysIndex
            -- TODO: FIXME outcomes are not storing the ways state
            System.WaitForSeconds(startDelay*2 + endDelay*2)
            BettrAudioController.PlayAudioLoop("rollupwins")                
            for waysCounterIndex = 1, waysCount do
                series
                    do
                        local isSlamStopped = BettrUserController.UserInSlamStopMode
                        if isSlamStopped then
                            break
                        end
                        local way = ways[waysCounterIndex]
                        local waySymbol = way.Symbol
                        local wayReelCount = way.ReelCount
                        local waySymbolCount = way.SymbolCount
                        local wayMultiplier = way.Multiplier
                        local wayPay = way.Pay
                        local wayTotalPay = way.Pays
                        System.Print("waySymbol={0} cascadeID={1}", waySymbol, cascadeID)
                        local wayMatrix = waysMatrix[waySymbol].Array
                        -- update status text 
                        local statusTexts = machine.StatusTexts
                        -- {0}        Pays  {1} x {2} ways = {3} CREDITS!!
                        statusTexts.FormatAndSetCurrentActive("PaysText", wayReelCount, wayPay, wayMultiplier, wayTotalPay)
                        local winSymbols = machine.WinSymbols
                        winSymbols.SetCurrentActive(waySymbol)
                        parallel
                            do
                                self:RollUpWaysWin(machine, way, waysState, waysSummary, duration)
                            end
                            do
                                -- display ways
                                for i=1,wayReelCount parallel do
                                    local reel = _G["Game001BaseGameReel" .. i]
                                    if reel != nil then
                                        reel.Mechanics.WaysMechanic:DisplayWays(reel, waySymbol, wayMatrix, waySymbolCount, duration)
                                        System.WaitForSeconds(duration)
                                        reel.Mechanics.WaysMechanic:HideWays(reel, waySymbol, wayMatrix, waySymbolCount)
                                    end
                                end
                            end
                        end
                    end
                end                            
            end
            waysIndex = waysState.WaysIndex
            waysState.WaysIndex = waysIndex + 1
            if waysIndex >= 0 then
                return
            end
            local isSlamStopped = BettrUserController.UserInSlamStopMode
            if isSlamStopped then
                return
            end
        end
    end
end

function Game001BaseGameMachineCascadingReelsMechanic:RollUpWaysWin(machine, way, waysState, waysSummary, duration)
    series
        do
            -- rollup ways win once
            local startDelay = waysSummary.DisplayLoopStartDelay
            local duration = waysSummary.DisplayLoopDuration
            local oldCoins = waysState.PaysRollup
            local pays = way.Pays
            local newCoins = oldCoins + pays            
            waysState.PaysRollup = newCoins
            System.WaitForSeconds(startDelay)
            local winTextProperty = machine.WinText            
            BettrVisualsController.RollUpCounter(winTextProperty, oldCoins, newCoins, duration)
        end
    end    
end

function Game001BaseGameMachineCascadingReelsMechanic:RollupCredits(machine)
    local oldCoins = BettrUser.Coins
    local newCoins = BettrUser.SpinCoins
    BettrUser.ApplySpinCoins()
    local pays = newCoins - oldCoins
    System.StartCoroutine(self, "OnRollupCredits", machine, oldCoins, newCoins, pays)
end

function Game001BaseGameMachineCascadingReelsMechanic:OnRollupCredits(machine, oldCoins, newCoins, pays)
    series
        do
            local winTextProperty = machine.WinText            
            if pays > 0 then
                BettrAudioController.PlayAudioLoop("rollupwins")            
                BettrVisualsController.RollUpCounter(winTextProperty, 0, pays, 0.3)
                System.WaitForSeconds(0.3)
                BettrAudioController.StopAudio()
            end
        end
        do
            local creditsTextProperty = machine.CreditsText   
            if pays ~= 0 then
                if pays > 0 then
                    BettrAudioController.PlayAudioLoop("rollupcoins")            
                end
                BettrVisualsController.RollUpCounter(creditsTextProperty, oldCoins, newCoins, 1)
                System.WaitForSeconds(1)
                BettrAudioController.StopAudio()
            end
        end
    end
end

function Game001BaseGameMachineCascadingReelsMechanic:TryPaying(machine)
    local summary = Game001BaseGameWaysSummary.Ways.First
    local count = summary.WaysCount
    if count == 0 then
        return
    end    
    local spinCoins = BettrUser.SpinCoins
    local ways = Game001BaseGameWays.Ways.Array
    for counterIndex = 1, count do
        local way = ways[counterIndex]
        local totalPay = way.Pays
        spinCoins = spinCoins + totalPay
    end
    BettrUser.SpinCoins = spinCoins
end



