require "math"
require "Core"

Game001BaseGameMachineCascadingReelsMechanic = {
}

function Game001BaseGameMachineCascadingReelsMechanic:new(o)
	o = o or {}
	setmetatable(o, self)
	self.__index = self
	return o
end

function Game001BaseGameMachineCascadingReelsMechanic:OnError(callStack)
	System.Error("BaseGameMachineCascadingReelsMechanic Error CallStack: {0}", callStack)
end

function Game001BaseGameMachineCascadingReelsMechanic:Initialize(machine)
end

function Game001BaseGameMachineCascadingReelsMechanic:TryPaying(machine)
end

function Game001BaseGameMachineCascadingReelsMechanic:BaseGamePayout(machine)
    series
        do
            machine:OnPayingCompleted()
        end
    end
end

function Game001BaseGameMachineCascadingReelsMechanic:OnPayingCompleted(machine)
    BettrAudioController.StopAudio()
    BettrUserController.DisableUserInSlamStopMode()
    machine:RollupCredits()
end

function Game001BaseGameMachineCascadingReelsMechanic:OnBaseGameSpinCompleted(machine)
    series
        do
            Game001BaseGameState.SpinState.First.State = "Completed"
            Game001BaseGameState.DisplayState.First.State = "Idle" 
        end
    end
end

function Game001BaseGameMachineCascadingReelsMechanic:RollupCredits(machine)
    local oldCoins = BettrUser.Coins
    local newCoins = BettrUser.SpinCoins
    BettrUser.ApplySpinCoins()
    local pays = newCoins - oldCoins
    System.Print("RollupCredits Old Coins={0} New Coins={1} Pays={2}", oldCoins, newCoins, pays)
    System.StartCoroutine(self, "OnRollupCredits", machine, oldCoins, newCoins, pays)
end

function Game001BaseGameMachineCascadingReelsMechanic:OnRollupCredits(machine, oldCoins, newCoins, pays)
    series
        do
            local winTextProperty = machine.WinText            
            if pays > 0 then
                BettrAudioController.PlayAudioLoop("rollupwins")            
                BettrVisualsController.RollUpCounter(winTextProperty, 0, pays, 0.3)
                System.WaitForSeconds(0.3)
                BettrAudioController.StopAudio()
            end
        end
        do
            local creditsTextProperty = machine.CreditsText   
            if pays ~= 0 then
                if pays > 0 then
                    BettrAudioController.PlayAudioLoop("rollupcoins")            
                end
                BettrVisualsController.RollUpCounter(creditsTextProperty, oldCoins, newCoins, 1)
                System.WaitForSeconds(1)
                BettrAudioController.StopAudio()
            end
        end
        do
            self:StartCascade(machine)
        end
    end
end

function Game001BaseGameMachineCascadingReelsMechanic:StartCascade(machine)
    series
        do                
            local cascadeCount = Game001BaseGameCascadingReelsSummary.CascadingReels.Count
            local cascades = Game001BaseGameCascadingReelsCascades.CascadingReels.Array
            local cascadesMatrix = Game001BaseGameCascadingReelsCascadesMatrix
            for counterIndex = 1, cascadeCount do
                local cascade = cascades[counterIndex]
                local cascadeID = cascade.Cascade
                local cascadeAction = cascade.Action
                local cascadeMatrix = cascadesMatrix[cascadeID].Array
                local cascadeMatrixCount = cascadesMatrix[cascadeID].Count
                for matrixIndex = 1, cascadeMatrixCount parallel do
                    local cascadeMatrixRow = cascadeMatrix[matrixIndex]
                    local cascadeReelID = cascadeMatrixRow.ReelID
                    local cascadeRowIndex = cascadeMatrixRow.RowIndex                     
                    if cascadeAction == "SymbolRemoval" then
                        -- run parallel symbol disappear animations
                        System.Print("Cascade Reel ID={0} Row Index={1}", cascadeReelID, cascadeRowIndex)
                        System.WaitForSeconds(1.0)
                    end
                end
            end                        
        end
        do
            machine:OnBaseGameSpinCompleted()
        end
    end
end



