require "math"
require "Core"

{{machineName}}BaseGameMachineCascadingReelsMechanic = {
}

function {{machineName}}BaseGameMachineCascadingReelsMechanic:new(o)
	o = o or {}
	setmetatable(o, self)
	self.__index = self
	return o
end

function {{machineName}}BaseGameMachineCascadingReelsMechanic:OnError(callStack)
	System.Error("BaseGameMachineCascadingReelsMechanic Error CallStack: {0}", callStack)
end

function {{machineName}}BaseGameMachineCascadingReelsMechanic:Initialize(machine)
end

function {{machineName}}BaseGameMachineCascadingReelsMechanic:OnBaseGameSpinCompleted(machine)
    series
        do
            self:StartCascade(machine)
        end        
        do
            {{machineName}}BaseGameState.SpinState.First.State = "Completed"
            {{machineName}}BaseGameState.DisplayState.First.State = "Idle" 
        end
    end
end

function {{machineName}}BaseGameMachineCascadingReelsMechanic:StartCascade(machine)
    series
        do                
            local cascadeCount = {{machineName}}BaseGameCascadingReelsSummary.CascadingReels.First.CascadeCount
            local cascades = {{machineName}}BaseGameCascadingReelsCascades.CascadingReels.Array
            local cascadesMatrix = {{machineName}}BaseGameCascadingReelsCascadesMatrix
            for counterIndex = 1, cascadeCount parallel do
                local cascade = cascades[counterIndex]
                local cascadeID = cascade.Cascade
                local cascadeAction = cascade.Action
                System.Print("cascadeID={0} counterIndex={1} cascadeAction={2}", cascadeID, counterIndex, cascadeAction)                                    
                local cascadeMatrix = cascadesMatrix[cascadeID].Array
                local cascadeMatrixCount = cascadesMatrix[cascadeID].Count
                if cascadeAction == "SymbolRemoval" then
                    self:SymbolRemovalActions(cascadeMatrix, cascadeMatrixCount, cascadeAction)
                elseif cascadeAction == "SymbolCascade" then
                    self:SymbolCascadeActions(cascadeMatrix, cascadeMatrixCount, cascadeAction)
                end
            end                        
        end
    end
end

function {{machineName}}BaseGameMachineCascadingReelsMechanic:SymbolRemovalActions(cascadeMatrix, cascadeMatrixCount, cascadeAction)
    for matrixIndex = 1, cascadeMatrixCount do
        local cascadeMatrixRow = cascadeMatrix[matrixIndex]
        local cascadeReelID = cascadeMatrixRow.ReelID
        local cascadeRowIndex = cascadeMatrixRow.RowIndex 
        System.Print("cascadeReelID={0} cascadeRowIndex={1} cascadeAction={2}", cascadeReelID, cascadeRowIndex, cascadeAction)                    
        self:SymbolRemovalAction(cascadeReelID, cascadeRowIndex)
    end
end

function {{machineName}}BaseGameMachineCascadingReelsMechanic:SymbolRemovalAction(reelID, rowIndex)
    local reel = _G["{{machineName}}BaseGame" .. reelID]
    local luaRowIndex = rowIndex + 1
    local symbolGroupProperty = reel["SymbolGroup" .. luaRowIndex]
    symbolGroupProperty.SetAllInactive()
end

function {{machineName}}BaseGameMachineCascadingReelsMechanic:SymbolCascadeActions(cascadeMatrix, cascadeMatrixCount, cascadeAction)
    for matrixIndex = 1, cascadeMatrixCount parallel do
        local cascadeMatrixRow = cascadeMatrix[matrixIndex]
        local cascadeReelID = cascadeMatrixRow.ReelID
        local rowIndex = cascadeMatrixRow.RowIndex
        local rowIndex2 = cascadeMatrixRow.RowIndex2 
        System.Print("cascadeReelID={0} rowIndex={1} rowIndex2={2} cascadeAction={3}", cascadeReelID, rowIndex, rowIndex2, cascadeAction)                    
        self:SymbolCascadeAction(cascadeReelID, rowIndex, rowIndex2)
    end
end

function {{machineName}}BaseGameMachineCascadingReelsMechanic:SymbolCascadeAction(reelID, rowIndex, rowIndex2)
    local reel = _G["{{machineName}}BaseGame" .. reelID]
    local luaRowIndex = rowIndex2 + 1
    local symbolGroupProperty = reel["SymbolGroup" .. luaRowIndex]   
end



