require "math"
require "Core"

{{machineName}}BaseGameMachineWaysMechanic = {
}

function {{machineName}}BaseGameMachineWaysMechanic:new(o)
	o = o or {}
	setmetatable(o, self)
	self.__index = self
	return o
end

function {{machineName}}BaseGameMachineWaysMechanic:OnError(callStack)
	System.Error("BaseGameMachineWaysMechanic Error CallStack: {0}", callStack)
end

function {{machineName}}BaseGameMachineWaysMechanic:Initialize(machine)
    -- Appending new entries to the table
    {{machineName}}BaseGameMachine.BaseGameStateDispatchTable.Paying = function()
        self:BaseGamePaying(machine)
    end
    {{machineName}}BaseGameMachine.BaseGameStateDispatchTable.WaitingForPayToComplete = function()
        self:WaitingForPayToComplete(machine)
    end
end

function {{machineName}}BaseGameMachineWaysMechanic:TryPaying(machine)
    local summary = {{machineName}}BaseGameWaysSummary.Ways.First
    local count = summary.WaysCount
    if count == 0 then
        return
    end    
    local spinCoins = BettrUser.SpinCoins
    local ways = {{machineName}}BaseGameWays.Ways.Array
    for counterIndex = 1, count do
        local way = ways[counterIndex]
        local totalPay = way.Pays
        spinCoins = spinCoins + totalPay
    end
    BettrUser.SpinCoins = spinCoins
end

function {{machineName}}BaseGameMachineWaysMechanic:BaseGamePaying(machine)
    {{machineName}}BaseGameState.SpinState.First.State = "WaitingForPayToComplete"
    local waysSummary = {{machineName}}BaseGameWaysSummary.Ways.First
    local count = waysSummary.WaysCount
    if count == 0 then
        machine:OnPayingCompleted()
        return
    end
    System.StartCoroutine(machine, "BaseGamePayout")
end

function {{machineName}}BaseGameMachineWaysMechanic:WaitingForPayToComplete(machine)    
end

function {{machineName}}BaseGameMachineWaysMechanic:BaseGamePayout(machine)
    series
        do
            local isSlamStopped = BettrUserController.UserInSlamStopMode
            if isSlamStopped then
                machine:OnPayingCompleted()
            else
                self:DisplayWays(machine)
            end
        end
    end        
end

function {{machineName}}BaseGameMachineWaysMechanic:DisplayWays(machine)
    series
        do
            local waysSummary = {{machineName}}BaseGameWaysSummary.Ways.First
            local waysCount = waysSummary.WaysCount
            if waysCount == 0 then
                machine:OnPayingCompleted()
                return
            end
            local waysState = {{machineName}}BaseGameWaysState.Ways.First
            waysState.PaysRollup = 0
            local ways = {{machineName}}BaseGameWays.Ways.Array
            local waysMatrix = {{machineName}}BaseGameWaysMatrix
            local waysCount = waysSummary.WaysCount 
            local startDelay = waysSummary.DisplayLoopStartDelay
            local duration = waysSummary.DisplayLoopDuration
            local endDelay = waysSummary.DisplayLoopEndDelay            
            local waysIndex = waysState.WaysIndex
            -- TODO: FIXME outcomes are not storing the ways state
            System.WaitForSeconds(startDelay*2 + endDelay*2)
            BettrAudioController.PlayAudioLoop("rollupwins")                
            for waysCounterIndex = 1, waysCount do
                series
                    do
                        local isSlamStopped = BettrUserController.UserInSlamStopMode
                        if isSlamStopped then
                            break
                        end
                        local way = ways[waysCounterIndex]
                        local waySymbol = way.Symbol
                        local wayReelCount = way.ReelCount
                        local waySymbolCount = way.SymbolCount
                        local wayMultiplier = way.Multiplier
                        local wayPay = way.Pay
                        local wayTotalPay = way.Pays
                        local wayMatrix = waysMatrix[waySymbol].Array
                        -- update status text 
                        local statusTexts = machine.StatusTexts
                        -- {0}        Pays  {1} x {2} ways = {3} CREDITS!!
                        statusTexts.FormatAndSetCurrentActive("PaysText", wayReelCount, wayPay, wayMultiplier, wayTotalPay)
                        local winSymbols = machine.WinSymbols
                        winSymbols.SetCurrentActive(waySymbol)
                        parallel
                            do
                                self:RollUpWaysWin(machine, way, waysState, waysSummary, duration)
                            end
                            do
                                -- display ways
                                for i=1,wayReelCount parallel do
                                    local reel = _G["{{machineName}}BaseGameReel" .. i]
                                    if reel != nil then
                                        reel.Mechanics.WaysMechanic:DisplayWays(reel, waySymbol, wayMatrix, waySymbolCount, duration)
                                        System.WaitForSeconds(duration)
                                        reel.Mechanics.WaysMechanic:HideWays(reel, waySymbol, wayMatrix, waySymbolCount)
                                    end
                                end
                            end
                        end
                    end
                end                            
            end
            waysIndex = waysState.WaysIndex
            waysState.WaysIndex = waysIndex + 1
            if waysIndex >= 0 then
                machine:OnPayingCompleted()
                return
            end
            local isSlamStopped = BettrUserController.UserInSlamStopMode
            if isSlamStopped then
                machine:OnPayingCompleted()
                return
            end
            System.StartCoroutine(machine, "BaseGamePayout")
        end
    end
end

function {{machineName}}BaseGameMachineWaysMechanic:RollUpWaysWin(machine, way, waysState, waysSummary, duration)
    series
        do
            -- rollup ways win once
            local startDelay = waysSummary.DisplayLoopStartDelay
            local duration = waysSummary.DisplayLoopDuration
            local oldCoins = waysState.PaysRollup
            local pays = way.Pays
            local newCoins = oldCoins + pays            
            waysState.PaysRollup = newCoins
            System.WaitForSeconds(startDelay)
            local winTextProperty = machine.WinText            
            BettrVisualsController.RollUpCounter(winTextProperty, oldCoins, newCoins, duration)
        end
    end    
end

function {{machineName}}BaseGameMachineWaysMechanic:OnPayingCompleted(machine)
    BettrAudioController.StopAudio()
    BettrUserController.DisableUserInSlamStopMode()
    machine:RollupCredits()
end

function {{machineName}}BaseGameMachineWaysMechanic:OnBaseGameSpinCompleted(machine)
    series
        do
            {{machineName}}BaseGameState.SpinState.First.State = "Completed"
            {{machineName}}BaseGameState.DisplayState.First.State = "Idle" 
        end
    end
end

function {{machineName}}BaseGameMachineWaysMechanic:RollupCredits(machine)
    local oldCoins = BettrUser.Coins
    local newCoins = BettrUser.SpinCoins
    BettrUser.ApplySpinCoins()
    local pays = newCoins - oldCoins
    System.StartCoroutine(self, "OnRollupCredits", machine, oldCoins, newCoins, pays)
end

function {{machineName}}BaseGameMachineWaysMechanic:OnRollupCredits(machine, oldCoins, newCoins, pays)
    series
        do
            local winTextProperty = machine.WinText            
            if pays > 0 then
                BettrAudioController.PlayAudioLoop("rollupwins")            
                BettrVisualsController.RollUpCounter(winTextProperty, 0, pays, 0.3)
                System.WaitForSeconds(0.3)
                BettrAudioController.StopAudio()
            end
        end
        do
            local creditsTextProperty = machine.CreditsText   
            if pays ~= 0 then
                if pays > 0 then
                    BettrAudioController.PlayAudioLoop("rollupcoins")            
                end
                BettrVisualsController.RollUpCounter(creditsTextProperty, oldCoins, newCoins, 1)
                System.WaitForSeconds(1)
                BettrAudioController.StopAudio()
            end
        end
        do
            machine:OnBaseGameSpinCompleted()
        end        
    end
end
