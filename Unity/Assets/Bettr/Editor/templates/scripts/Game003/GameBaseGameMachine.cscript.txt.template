require "math"
require "Core"
require "{{machineName}}BaseGameReel"

{{machineName}}BaseGameMachine = {
}

function {{machineName}}BaseGameMachine:new(o)
	o = o or {}
	setmetatable(o, self)
	self.__index = self
	return o
end

function {{machineName}}BaseGameMachine:destroy()
	System.Print("{{machineName}}BaseGameMachine destroy tile id={0}", self.id)
end

function {{machineName}}BaseGameMachine:OnError(callStack)
	System.Error("{{machineName}}BaseGameMachine Error CallStack: {0}", callStack)
end

function {{machineName}}BaseGameMachine:Awake()
	System.Print("{{machineName}}BaseGameMachine Awake tile id={0}", self.id)
end

function {{machineName}}BaseGameMachine:Start()
    series
        do
	        self:ConfigureSettings()
	        self:ShowSettings()
	        self:PlayStartAnimations()
	        self:StartEngines()
        end
    end
end

function {{machineName}}BaseGameMachine:OnSpinButtonClicked()
    self:CancelPaylinesAnimation()
    series
        do
            self:WaitForPayToComplete()                       
            self:SpinEngines()
            self:WaitForApplyOutcomeDelay()
            self:LoadServerOutcome()
            self:OnOutcomeReceived()
        end
    end
end

function {{machineName}}BaseGameMachine:CancelPaylinesAnimation()
    {{machineName}}BaseGameState.DisplayState.First.State = "CancelRequested"
end

function {{machineName}}BaseGameMachine:RollUpPaylinesWin(paylinesSummary)
    series
        do
            -- rollup paylines win once
            local startDelay = paylinesSummary.DisplayLoopStartDelay
            local duration = paylinesSummary.DisplayLoopDuration
            local pays = paylinesSummary.Pays 
            System.WaitForSeconds(startDelay)
            local winTextProperty = self.WinText
            
            BettrVisualsController.RollUpCounter(winTextProperty, 0, pays, 1)
            
            local creditsTextProperty = self.CreditsText   
            local oldCoins = BettrUser.Coins
            local newCoins = oldCoins + pays            
            BettrUser.Coins = newCoins  
                      
            BettrVisualsController.RollUpCounter(creditsTextProperty, oldCoins, newCoins, 1)
        end
    end    
end

function {{machineName}}BaseGameMachine:WaitForPayToComplete()
    series
        do
            if {{machineName}}BaseGameState.SpinState.First.State == "WaitingForPayToComplete" then
                local paylinesSummary = {{machineName}}BaseGamePaylinesSummary.Paylines.First
                local delay = paylinesSummary.DisplayLoopEndDelay
                while {{machineName}}BaseGameState.SpinState.First.State == "WaitingForPayToComplete" do
                    {{machineName}}BaseGameState.DisplayState.First.State = "CancelRequested"
                    System.WaitForSeconds(delay)
                end
            end
            {{machineName}}BaseGameState.DisplayState.First.State = "Idle"            
        end
    end
end

function {{machineName}}BaseGameMachine:WaitingForPayToComplete()    
end

function {{machineName}}BaseGameMachine:BaseGamePaying()
    {{machineName}}BaseGameState.SpinState.First.State = "WaitingForPayToComplete"
    System.StartCoroutine(self, "BaseGamePayout")
end

function {{machineName}}BaseGameMachine:ConfigureSettings()
    self.CreditsText.SetText(BettrUser.Coins)
    self.WinText.SetText("0")       
    self.BetText.SetText({{machineName}}BetMultiplierState.Current.First.BetMultiplier) 
end

function {{machineName}}BaseGameMachine:ShowSettings()
    series
        do
            local settings = self["Settings"]
            settings.SetActive(true)
        end
    end
end

function {{machineName}}BaseGameMachine:HideSettings()
    series
        do
            local settings = self["Settings"]
            settings.SetActive(false)
        end
    end
end

function {{machineName}}BaseGameMachine:ResetSettings()
    self.WinText.SetText("0")
end

function {{machineName}}BaseGameMachine:Update()
    local spinState = {{machineName}}BaseGameState.SpinState.First.State
    self.BaseGameStateDispatchTable[spinState](self)    
end

function {{machineName}}BaseGameMachine:BaseGameSpinning()    
end

function {{machineName}}BaseGameMachine:BaseGameWaiting()    
end

function {{machineName}}BaseGameMachine:BaseGameCompleted()
   self:ShowSettings()
   {{machineName}}BaseGameState.SpinState.First.State = "Waiting"
end

function {{machineName}}BaseGameMachine:OnBaseGameSpinCompleted()
    series
        do
            {{machineName}}BaseGameState.SpinState.First.State = "Completed"
        end
    end
end

function {{machineName}}BaseGameMachine:BaseGamePayout()
    series
        do
            local paylinesSummary = {{machineName}}BaseGamePaylinesSummary.Paylines.First
            local paylinesIndex = paylinesSummary.PaylinesIndex
            local paylinesCount = paylinesSummary.PaylinesCount
            if paylinesCount > 0 then
                local paylines = {{machineName}}BaseGamePaylines.Paylines.Array
                local paylinesMatrix = {{machineName}}BaseGamePaylinesMatrix
                parallel
                    do
                        self:DisplayPaylines(paylinesSummary, paylinesMatrix, paylines)            
                    end
                    do
                        if paylinesIndex == 0 then
                            self:RollUpPaylinesWin(paylinesSummary)
                        end
                    end
                end
                if paylinesIndex >= 2 then
                    self:OnPayingCompleted()
                elseif {{machineName}}BaseGameState.DisplayState.First.State == "CancelRequested" then
                    self:OnPayingCompleted()
                else
                    System.StartCoroutine(self, "BaseGamePayout")
                end
            else
                self:OnPayingCompleted()
            end
        end
    end      
end

function {{machineName}}BaseGameMachine:DisplayPaylines(paylinesSummary, paylinesMatrix, paylines)
    series
        do
            local paylinesIndex = paylinesSummary.PaylinesIndex   
            local paylinesCount = paylinesSummary.PaylinesCount 
            local startDelay = paylinesSummary.DisplayLoopStartDelay
            local duration = paylinesSummary.DisplayLoopDuration
            local endDelay = paylinesSummary.DisplayLoopEndDelay            
            if paylinesIndex == 0 then
                System.WaitForSeconds(startDelay)
            end
            for paylinesCounterIndex = 1, paylinesCount do
                series
                    do
                        if {{machineName}}BaseGameState.DisplayState.First.State == "CancelRequested" then
                            break
                        end
                        local payline = paylines[paylinesCounterIndex]
                        local paylineId = payline.PaylineId
                        local paylineSymbol = payline.Symbol
                        local paylineReelCount = payline.ReelCount
                        local paylineMultiplier = payline.Multiplier
                        local paylinePay = payline.Pay
                        local paylineTotalPay = payline.Pays
                        local paylineData = paylinesMatrix[paylineId].Array
                        -- update status text 
                        local statusTexts = self.StatusTexts
                        -- Line {0} Wins  = {1} CREDITS!!
                        statusTexts.FormatAndSetCurrentActive("PaysText", paylineId, paylineTotalPay)
                        local winSymbols = self.WinSymbols
                        winSymbols.SetCurrentActive(paylineSymbol)
                        -- display paylines
                        for i=1, paylineReelCount parallel do
                            local reel = _G["{{machineName}}BaseGameReel" .. i]
                            if reel ~= nil then
                                reel:DisplayPaylines(paylineSymbol, paylineData, paylineId, duration)
                                System.WaitForSeconds(duration)
                                reel:HidePaylines(paylineSymbol, paylineData, paylineId)
                            end
                        end
                    end
                end                            
            end
            paylinesSummary.PaylinesIndex = paylinesIndex + 1
            System.WaitForSeconds(endDelay) 
        end
    end
end

function {{machineName}}BaseGameMachine:UpdateStatusText(text)
end

function {{machineName}}BaseGameMachine:PlayStartAnimations()
    series
        do
            local animatorProperty = self["start"]
            BettrVisualsController.PlayAnimatorProperty(animatorProperty)
        end        
    end
end

function {{machineName}}BaseGameMachine:StartEngines()
    parallel
    {{ for reelIndex in 1..reelCount }}
        do
            {{machineName}}BaseGameReel{{ reelIndex }}:StartEngines()
        end
    {{ end }}
    end
end

function {{machineName}}BaseGameMachine:LoadServerOutcome()
    series
        do
            BettrOutcomeController.LoadServerOutcome("{{machineName}}")
        end
    end
end

function {{machineName}}BaseGameMachine:WaitForApplyOutcomeDelay()
    series
        do
            local outcomeDelayInMs = {{machineName}}BaseGameSpinProperties.ApplyOutcomeDelay.First.Value
            if outcomeDelayInMs > 0 then
                System.WaitForSeconds(outcomeDelayInMs / 1000)
            end
        end
    end
end

function {{machineName}}BaseGameMachine:SpinEngines()
    {{machineName}}BaseGameState.SpinState.First.State = "Spinning"
    local statusTexts = self.StatusTexts
    statusTexts.SetCurrentActive("GoodLuckText")
    local winSymbols = self.WinSymbols
    winSymbols.SetAllInactive()
    self:ResetSettings()
    parallel
        {{ for reelIndex in 1..reelCount }}
            do
                {{machineName}}BaseGameReel{{ reelIndex }}:SpinEngines()
            end
        {{ end }}
    end
end

function {{machineName}}BaseGameMachine:UpdateBaseGameReelsSpinState(state)
{{ for reelIndex in 1..reelCount }}
    {{machineName}}BaseGameReelSpinState.Reel{{ reelIndex }}.First.ReelSpinState = state
{{ end }}
end

function {{machineName}}BaseGameMachine:TryPaying()
    {{machineName}}BaseGameState.SpinState.First.State = "Paying"
end

function {{machineName}}BaseGameMachine:CurrentSpinState()
    return {{machineName}}BaseGameState.SpinState.First.State
end

function {{machineName}}BaseGameMachine:OnPayingCompleted()
    self:OnBaseGameSpinCompleted()
end

function {{machineName}}BaseGameMachine:OnSpinReelsStopped()
    self:UpdateBaseGameReelsSpinState("Waiting")
    self:TryPaying()
end

function {{machineName}}BaseGameMachine:OnOutcomeReceived()
    parallel
        {{ for reelIndex in 1..reelCount }}
            do
                {{machineName}}BaseGameReel{{ reelIndex }}:OnOutcomeReceived()
            end
        {{ end }}
    end
end

function {{machineName}}BaseGameMachine:OnPointerClick()
    System.Print("{{machineName}}BaseGameMachine OnPointerClick tile id={0}", self.id)
    System.StartCoroutine(self, "OnSpinButtonClicked")
end

function {{machineName}}BaseGameMachine:OnBecameVisible()
	System.Print("{{machineName}}BaseGameMachine OnBecameVisible tile id={0}", self.id)
end

{{machineName}}BaseGameMachine.BaseGameStateDispatchTable = {
    Waiting = {{machineName}}BaseGameMachine.BaseGameWaiting,
    Spinning = {{machineName}}BaseGameMachine.BaseGameSpinning,
    Completed = {{machineName}}BaseGameMachine.BaseGameCompleted,
    Paying = {{machineName}}BaseGameMachine.BaseGamePaying,
    WaitingForPayToComplete = {{machineName}}BaseGameMachine.WaitingForPayToComplete,
}

return {{machineName}}BaseGameMachine:new()